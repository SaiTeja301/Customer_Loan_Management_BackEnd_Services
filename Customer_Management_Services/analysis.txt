
================================================================================
   ENTERPRISE SPRING BOOT BACKEND — COMPLETE ANALYSIS & INTERVIEW NOTES
   Project: Customer_Management_Services (Customer Loan Management System)
   Tech: Spring Boot 3.2 | Java 17 | MySQL | JPA/Hibernate | Lombok | Swagger
================================================================================

========================  PART 1: SPRING BOOT ARCHITECTURE OVERVIEW  ========================

1.1 WHAT IS SPRING FRAMEWORK
─────────────────────────────
Definition:
  Spring is a comprehensive, open-source Java framework that provides
  infrastructure support for building enterprise Java applications.

Core Principles:
  • Inversion of Control (IoC) — Framework controls object creation
  • Dependency Injection (DI)  — Dependencies are injected, not created manually
  • Aspect-Oriented Programming (AOP) — Cross-cutting concerns (logging, security)

Internal Working:
  Spring uses an IoC Container (ApplicationContext) that:
  1. Reads configuration (annotations / XML / Java config)
  2. Creates beans (objects) at startup
  3. Manages bean lifecycle (creation → initialization → use → destruction)
  4. Injects dependencies automatically

Interview Answer:
  "Spring Framework is a lightweight, open-source Java framework based on IoC
   and DI principles. It eliminates boilerplate code and provides a modular
   architecture where the framework manages object creation and wiring."

1.2 WHAT IS SPRING BOOT
─────────────────────────
Definition:
  Spring Boot is an opinionated extension of Spring Framework that simplifies
  configuration and enables rapid application development.

Key Features:
  • Auto-Configuration — Automatically configures based on dependencies
  • Embedded Server   — Tomcat/Jetty/Undertow built-in (no WAR deployment)
  • Starter POMs      — Pre-configured dependency bundles
  • Actuator          — Production-ready monitoring
  • application.yml   — Externalized configuration

Your Project Uses:
  - spring-boot-starter-web       → Embedded Tomcat + Spring MVC
  - spring-boot-starter-data-jpa  → Hibernate + Spring Data JPA
  - spring-boot-starter-validation → Bean Validation (Jakarta)

Interview Answer:
  "Spring Boot removes manual configuration overhead. It provides auto-config,
   embedded servers, and starter dependencies so developers focus on business
   logic, not infrastructure setup."

1.3 WHY SPRING BOOT IN ENTERPRISE
───────────────────────────────────
  • Rapid Development     — Convention over configuration
  • Production-Ready      — Built-in health checks, metrics
  • Microservice-Friendly — Lightweight, independently deployable
  • Ecosystem             — Spring Security, Spring Cloud, Spring Data
  • Community & Support   — Largest Java framework ecosystem

1.4 MONOLITHIC vs MICROSERVICES
────────────────────────────────
  YOUR PROJECT = Monolithic Architecture (single deployable unit)

  Monolithic:
    ┌─────────────────────────────────────────┐
    │  Controller + Service + Repository      │
    │  All in ONE application, ONE database   │
    └─────────────────────────────────────────┘

  Microservices:
    ┌──────────┐  ┌──────────┐  ┌──────────┐
    │ Customer │  │  Loan    │  │   AI     │
    │ Service  │  │ Service  │  │ Service  │
    │  + DB    │  │  + DB    │  │  + API   │
    └──────────┘  └──────────┘  └──────────┘

1.5 COMPLETE RUNTIME FLOW (YOUR PROJECT)
─────────────────────────────────────────
  Client (Angular/Postman)
    │
    ▼ HTTP Request: POST /Spr/customers/insertCustomer
    │
  ┌─────────────────────────────┐
  │ Embedded Tomcat Server      │ ← Receives HTTP request
  │ (port 8080)                 │
  └────────────┬────────────────┘
               ▼
  ┌─────────────────────────────┐
  │ DispatcherServlet           │ ← Front controller, routes request
  └────────────┬────────────────┘
               ▼
  ┌─────────────────────────────┐
  │ CustomerController          │ ← @RestController receives request
  │ insertCustomer(CustomerDto) │    Validates input (@Valid)
  └────────────┬────────────────┘
               ▼
  ┌─────────────────────────────┐
  │ customerServiceImpl         │ ← @Service processes business logic
  │ insertCustomer()            │    Converts DTO → BO (entity)
  └────────────┬────────────────┘
               ▼
  ┌─────────────────────────────┐
  │ CustomerRepository          │ ← JpaRepository generates SQL
  │ .save(customerBo)           │    Hibernate ORM maps to table
  └────────────┬────────────────┘
               ▼
  ┌─────────────────────────────┐
  │ MySQL Database              │ ← INSERT INTO Spring_Customers ...
  │ testschema.Spring_Customers │
  └────────────┬────────────────┘
               ▼
  Response flows back:
  Database → Repository → Service (BO→DTO) → Controller (DTO→VO) → Client


========================  PART 2: YOUR PROJECT STRUCTURE  ========================

2.1 ACTUAL PROJECT FOLDER STRUCTURE
─────────────────────────────────────
  src/main/java/com/SprCustomers/
  │
  ├── Customer_Management_ServicesApplication.java   ← Main entry point
  │
  ├── Controller/
  │   ├── CustomerController.java           ← REST API endpoints
  │   └── CustomerControllerInterface.java  ← Controller contract
  │
  ├── Service/
  │   ├── CustomerService.java              ← Service interface
  │   ├── customerServiceImpl.java          ← Business logic implementation
  │   ├── GeminiAiService.java              ← AI service interface
  │   └── GeminiAiServiceImpl.java          ← Gemini AI integration
  │
  ├── Dao/
  │   └── CustomerRepository.java           ← JPA Repository (data access)
  │
  ├── Bo/
  │   └── CustomerBo.java                   ← Entity/Business Object (JPA)
  │
  ├── Dto/
  │   ├── CustomerDto.java                  ← Data Transfer Object
  │   ├── CustomerUpdateRequest.java        ← Partial update DTO
  │   ├── AiRequest.java                    ← AI request DTO
  │   └── AiResponse.java                   ← AI response DTO
  │
  ├── Vo/
  │   └── CustomerVo.java                   ← View Object (API response)
  │
  ├── Config/
  │   └── CorsConfig.java                   ← CORS configuration
  │
  ├── Exception/
  │   └── GlobalExceptionHandler.java       ← Global exception handling
  │
  └── Mapper/
      └── ModelMapperExp.java               ← ModelMapper bean config

  src/main/resources/
  └── application.yml                       ← App configuration (DB, server)

2.2 PURPOSE OF EACH PACKAGE
─────────────────────────────
  Bo (Business Object / Entity):
    Maps to database tables. JPA annotations define ORM mapping.
    Example: CustomerBo → Spring_Customers table

  Dto (Data Transfer Object):
    Carries data between layers. Contains validation annotations.
    Example: CustomerDto with @NotBlank, @Positive

  Vo (View Object):
    Formats data for client. All String fields for display.
    Example: CustomerVo converts Float to String

  Dao (Data Access Object / Repository):
    Interfaces that extend JpaRepository for database operations.
    Example: CustomerRepository extends JpaRepository<CustomerBo, Integer>

  Service:
    Contains business logic. Interface + Implementation pattern.
    Example: CustomerService (interface) + customerServiceImpl

  Controller:
    Exposes REST API endpoints. Handles HTTP request/response.
    Example: CustomerController with @GetMapping, @PostMapping

  Config:
    Application-wide configuration beans.
    Example: CorsConfig for cross-origin settings

  Exception:
    Centralized error handling with @ControllerAdvice.
    Example: GlobalExceptionHandler

  Mapper:
    Object mapping configuration.
    Example: ModelMapperExp provides ModelMapper bean


========================  PART 3: APPLICATION STARTUP INTERNAL WORKING  ========================

3.1 MAIN METHOD (Your Project)
───────────────────────────────
  @SpringBootApplication
  public class Customer_Management_ServicesApplication {
      public static void main(String[] args) {
          SpringApplication.run(Customer_Management_ServicesApplication.class, args);
      }
  }

3.2 WHAT HAPPENS WHEN main() EXECUTES
───────────────────────────────────────
  Step 1: JVM calls main()
  Step 2: SpringApplication.run() triggers Spring Boot bootstrap
  Step 3: @SpringBootApplication activates 3 things:

  @SpringBootApplication = @Configuration
                          + @EnableAutoConfiguration
                          + @ComponentScan

  @Configuration:
    Marks this class as a source of bean definitions

  @EnableAutoConfiguration:
    Spring Boot reads META-INF/spring.factories
    Automatically configures:
    - DataSource (MySQL connection from application.yml)
    - EntityManagerFactory (Hibernate)
    - TransactionManager
    - Embedded Tomcat
    - DispatcherServlet

  @ComponentScan:
    Scans com.SprCustomers package and ALL sub-packages
    Finds and registers:
    - @RestController → CustomerController
    - @Service        → customerServiceImpl, GeminiAiServiceImpl
    - @Repository     → CustomerRepository
    - @Configuration  → CorsConfig, ModelMapperExp
    - @ControllerAdvice → GlobalExceptionHandler

3.3 BEAN CREATION LIFECYCLE
─────────────────────────────
  1. Bean Definition   — Spring discovers annotated classes
  2. Instantiation     — Creates objects using constructors
  3. Dependency Inject — Injects required dependencies
  4. @PostConstruct    — Calls init methods (e.g., GeminiAiServiceImpl.init())
  5. Ready             — Bean is ready to serve requests
  6. @PreDestroy       — Cleanup before shutdown

  YOUR PROJECT'S BEAN CREATION ORDER:
    ModelMapper bean (from ModelMapperExp)
      → CustomerRepository (auto-implemented by Spring Data)
        → customerServiceImpl (needs ModelMapper + Repository)
          → GeminiAiServiceImpl (needs CustomerService)
            → CustomerController (needs CustomerService + GeminiAiService)
              → CorsConfig, GlobalExceptionHandler

3.4 ApplicationContext
───────────────────────
  The IoC container that holds all beans:
  - AnnotationConfigServletWebServerApplicationContext (your app)
  - Acts as a bean factory + event publisher + resource loader

Interview Question: "What happens when Spring Boot application starts?"
Answer: "The main() method calls SpringApplication.run(), which creates an
 ApplicationContext, performs component scanning to find @Component-annotated
 classes, runs auto-configuration based on classpath dependencies, creates
 and wires all beans, starts the embedded Tomcat server, and runs any
 @PostConstruct initialization methods."


========================  PART 4: CONTROLLER LAYER DEEP EXPLANATION  ========================

4.1 @RestController vs @Controller
─────────────────────────────────────
  @Controller:
    Returns view names → resolved by ViewResolver (Thymeleaf/JSP)
    Needs @ResponseBody on each method to return data

  @RestController = @Controller + @ResponseBody
    Every method automatically serializes return value to JSON/XML
    Used for REST APIs (YOUR PROJECT uses this)

4.2 YOUR CustomerController BREAKDOWN
────────────────────────────────────────
  @RestController                              ← REST API controller
  @RequestMapping("/Spr/customers")            ← Base URL prefix
  @CrossOrigin                                 ← Allow cross-origin requests
  @Tag(name = "Customer Management")           ← Swagger documentation
  public class CustomerController {

      // Constructor Injection (Best Practice over @Autowired)
      private final CustomerService service;
      private final GeminiAiService geminiAiService;

      public CustomerController(CustomerService service,
                                GeminiAiService geminiAiService) {
          this.service = service;
          this.geminiAiService = geminiAiService;
      }
  }

4.3 HTTP MAPPING ANNOTATIONS
──────────────────────────────
  @GetMapping("/getAllCustomers")       → HTTP GET    → Read data
  @GetMapping("/getCustomerById")      → HTTP GET    → Read single record
  @PostMapping("/insertCustomer")      → HTTP POST   → Create new record
  @PutMapping("/updateCustomerById")   → HTTP PUT    → Update existing record
  @DeleteMapping("/deleteCustomerById/{id}") → HTTP DELETE → Remove record
  @PostMapping("/askAgent")            → HTTP POST   → AI query

4.4 PARAMETER ANNOTATIONS
───────────────────────────
  @RequestBody   → Deserializes JSON body → Java object
                   Example: @RequestBody CustomerDto customerDto
  @RequestParam  → Extracts query parameter
                   Example: @RequestParam int id → /getCustomerById?id=5
  @PathVariable  → Extracts from URL path
                   Example: @PathVariable Integer id → /deleteCustomerById/5
  @Valid         → Triggers bean validation on the request body

4.5 REQUEST LIFECYCLE INTERNALLY
──────────────────────────────────
  Client sends: POST /Spr/customers/insertCustomer
  Body: {"customerName":"John","customerAddress":"NYC","principalAmount":10000,...}

  Step 1: Tomcat receives TCP connection → creates HttpServletRequest
  Step 2: DispatcherServlet.doDispatch() invoked
  Step 3: HandlerMapping finds CustomerController.insertCustomer()
  Step 4: HandlerAdapter invokes the method
  Step 5: @RequestBody → HttpMessageConverter → Jackson deserializes JSON → CustomerDto
  Step 6: @Valid → Hibernate Validator validates fields
  Step 7: Method executes → calls service → returns ResponseEntity
  Step 8: Jackson serializes ResponseEntity body → JSON
  Step 9: Response sent with HTTP status code

Interview Question: "Explain @RestController vs @Controller"
Answer: "@Controller is for MVC views, @RestController combines @Controller
 and @ResponseBody so every method returns data directly (JSON/XML) instead
 of view names. In REST APIs, we always use @RestController."


========================  PART 5: SERVICE LAYER DEEP EXPLANATION  ========================

5.1 ROLE OF SERVICE LAYER
───────────────────────────
  • Contains ALL business logic
  • Sits between Controller and Repository
  • Handles data transformation (BO ↔ DTO)
  • Manages transactions
  • Keeps Controller thin and Repository focused on data access

5.2 INTERFACE + IMPLEMENTATION PATTERN
────────────────────────────────────────
  WHY Interface?
  • Loose coupling — Controller depends on interface, not implementation
  • Testability    — Easy to mock in unit tests
  • Swappability   — Can switch implementations without changing controller
  • Proxy creation — Spring creates JDK dynamic proxy for transaction management

  YOUR PROJECT:
    CustomerService (interface)
      └─ customerServiceImpl (implementation, @Service)

    GeminiAiService (interface)
      └─ GeminiAiServiceImpl (implementation, @Service)

5.3 @Service ANNOTATION INTERNAL WORKING
──────────────────────────────────────────
  @Service is a specialization of @Component
  Component Scan finds it → Registers as Spring Bean
  Spring creates SINGLETON instance (default scope)
  Bean name = "customerServiceImpl" (lowercase first letter)

5.4 KEY BUSINESS LOGIC IN YOUR SERVICE
────────────────────────────────────────
  insertCustomer():
    1. Validates input (null check)
    2. Maps DTO → BO (entity)
    3. Calls repository.save(bo) → INSERT SQL
    4. Converts saved BO → DTO (with computed fields)
    5. Returns DTO to controller

  toDto() method — Computed Fields:
    Interest = (Principal × Rate × Time) / 100    ← Simple Interest formula
    Total    = Principal + Interest
    These are @Transient fields — NOT stored in database, computed on the fly

5.5 TRANSACTION MANAGEMENT
────────────────────────────
  @Transactional(readOnly = true)  → Read operations (optimized, no dirty checking)
  @Transactional                    → Write operations (full transaction support)

  Internal Working:
    Spring creates a PROXY around your service bean
    Before method: BEGIN TRANSACTION
    Method executes successfully: COMMIT
    Method throws RuntimeException: ROLLBACK

Interview Question: "Why use interface for service layer?"
Answer: "Interfaces provide loose coupling, testability through mocking,
 and allow Spring to create JDK dynamic proxies for cross-cutting concerns
 like transaction management. It also follows the Dependency Inversion
 Principle — high-level modules depend on abstractions, not implementations."


========================  PART 6: REPOSITORY LAYER DEEP EXPLANATION  ========================

6.1 YOUR REPOSITORY
─────────────────────
  @Repository
  public interface CustomerRepository extends JpaRepository<CustomerBo, Integer> {
      int deleteByCustomerId(Integer id);
  }

6.2 JpaRepository INTERNAL WORKING
─────────────────────────────────────
  JpaRepository<CustomerBo, Integer>
    CustomerBo = Entity type
    Integer    = Primary key type (customerId)

  Inheritance Chain:
    JpaRepository
      └─ ListCrudRepository + ListPagingAndSortingRepository
           └─ CrudRepository + PagingAndSortingRepository
                └─ Repository (marker interface)

  METHODS PROVIDED FOR FREE:
    save(entity)      → INSERT or UPDATE (checks if ID exists)
    findById(id)      → SELECT WHERE CID = ?
    findAll()         → SELECT * FROM Spring_Customers
    delete(entity)    → DELETE WHERE CID = ?
    deleteById(id)    → DELETE by primary key
    count()           → SELECT COUNT(*)
    existsById(id)    → SELECT EXISTS(...)

6.3 HOW SPRING DATA IMPLEMENTS YOUR INTERFACE
────────────────────────────────────────────────
  At startup:
  1. Spring Data finds interfaces extending JpaRepository
  2. Creates a PROXY implementation class (SimpleJpaRepository)
  3. Registers this proxy as a Spring Bean
  4. All method calls are intercepted by the proxy

  Custom method: deleteByCustomerId(Integer id)
  → Spring Data uses Query Derivation:
    "deleteBy" → DELETE operation
    "CustomerId" → WHERE customerId = :id
    Generated JPQL: DELETE FROM CustomerBo c WHERE c.customerId = ?1

6.4 HIBERNATE INTERNAL WORKING
────────────────────────────────
  Hibernate is the JPA implementation (ORM framework)

  EntityManager (JPA) → Session (Hibernate) → manages entity lifecycle:
    Transient  → new CustomerBo() — not tracked
    Persistent → after save() — tracked, changes auto-synced
    Detached   → after transaction ends — no longer tracked
    Removed    → after delete() — scheduled for deletion

  Persistence Context (First Level Cache):
    Hibernate caches entities within a transaction
    findById(5) called twice → only ONE SQL query

Interview Question: "How does Spring Data JPA generate queries?"
Answer: "Spring Data creates proxy implementations at startup. For standard
 CRUD, it uses SimpleJpaRepository. For custom methods, it uses Query
 Derivation — parsing the method name into JPQL. For example,
 findByCustomerName generates 'SELECT c FROM CustomerBo c WHERE c.customerName = ?1'."


========================  PART 7: ENTITY (BO) LAYER DEEP EXPLANATION  ========================

7.1 YOUR ENTITY — CustomerBo.java
───────────────────────────────────
  @Entity                                          ← Marks as JPA entity
  @Table(name = "Spring_Customers", schema = "testschema")  ← Table mapping
  @Getter @Setter                                  ← Lombok generates getters/setters
  public class CustomerBo {

      @Id                                          ← Primary key
      @GeneratedValue(strategy = GenerationType.IDENTITY)  ← Auto-increment
      @Column(name = "CID")                        ← Maps to column CID
      private Integer customerId;

      @Column(name = "Customer_Name")
      private String customerName;

      @Column(name = "`Interest_Rate`")            ← Backticks for reserved words
      private Float interestRate;

      @Transient                                   ← NOT stored in database
      private Float rateofInterstAmount;            ← Calculated at runtime

      @Transient
      private Float totalAmount;                    ← Calculated at runtime
  }

7.2 ORM MAPPING EXPLAINED
───────────────────────────
  Java Class          →  Database Table
  CustomerBo          →  testschema.Spring_Customers
  customerId (Integer)→  CID (INT AUTO_INCREMENT PRIMARY KEY)
  customerName        →  Customer_Name (VARCHAR)
  interestRate        →  Interest_Rate (FLOAT)
  principalAmount     →  Principle_Amount (FLOAT)
  time                →  Time (FLOAT)

7.3 @GeneratedValue STRATEGIES
────────────────────────────────
  IDENTITY   → Database auto-increment (MySQL, SQL Server) ← YOUR PROJECT
  SEQUENCE   → Database sequence (Oracle, PostgreSQL)
  TABLE      → Separate table maintains IDs
  AUTO       → JPA provider chooses strategy

7.4 @Transient — Computed Fields
──────────────────────────────────
  rateofInterstAmount and totalAmount are @Transient:
  → NOT mapped to any column
  → NOT stored in database
  → Calculated in Java code (toDto method in service)
  → Interest = (P × R × T) / 100

Interview Question: "What is the difference between @Entity and @Table?"
Answer: "@Entity marks a Java class as a JPA entity that Hibernate should
 manage. @Table specifies the exact database table name and schema. Without
 @Table, the table name defaults to the class name."


========================  PART 8: DTO LAYER DEEP EXPLANATION  ========================

8.1 YOUR DTOs
──────────────
  CustomerDto:
    - Used for creating customers (input) and returning data (output)
    - Has validation: @NotBlank, @NotNull, @Positive
    - Contains computed fields: rateofInterstAmount, totalAmount

  CustomerUpdateRequest:
    - Partial update DTO — ALL fields nullable (optional)
    - Only non-null fields update the entity (patch semantics)

  AiRequest:
    - Carries the question string to AI endpoint
    - @NotBlank validation on question field

  AiResponse:
    - Returns AI answer + timestamp
    - Timestamp auto-set in constructor

8.2 WHY DTO vs ENTITY
───────────────────────
  Entity (BO):
    - Tied to database schema
    - Contains JPA annotations (@Entity, @Column)
    - Should never be exposed to client directly
    - Security risk: exposes internal structure

  DTO:
    - Decoupled from database
    - Contains validation annotations
    - Can have different field names/types than entity
    - Safe to expose to client

  Data Flow:
    Client JSON → DTO (validated) → Service converts → BO (entity) → Database
    Database → BO → Service converts → DTO (enriched) → Controller → VO → Client JSON

8.3 VO (View Object) — YOUR PROJECT'S EXTRA LAYER
───────────────────────────────────────────────────
  CustomerVo has ALL fields as String (for display formatting)
  Controller converts DTO → VO before sending response

  This provides:
    - Display-friendly formatting
    - Client doesn't know internal data types
    - Additional layer of abstraction

Interview Question: "Why use DTO instead of Entity in API?"
Answer: "DTOs decouple API contract from database schema. This prevents
 exposing sensitive fields, allows independent API evolution, enables
 validation rules specific to API input, and avoids lazy-loading
 issues with JPA entities."


========================  PART 9: JWT AUTHENTICATION (CONCEPTS)  ========================

NOTE: Your project does NOT currently have JWT/Security. This section covers
concepts for interview preparation.

9.1 WHAT IS JWT
────────────────
  JSON Web Token — A compact, self-contained token for secure data transmission.

9.2 JWT STRUCTURE
──────────────────
  Header.Payload.Signature

  Header:  {"alg": "HS256", "typ": "JWT"}  → Base64Url encoded
  Payload: {"sub": "user@email.com", "role": "ADMIN", "exp": 1700000000}
  Signature: HMACSHA256(base64(header) + "." + base64(payload), secretKey)

9.3 AUTHENTICATION FLOW
─────────────────────────
  1. Client: POST /auth/login  {username, password}
  2. Server: Validates credentials against database
  3. Server: Generates JWT with user details + expiration
  4. Client: Stores JWT (localStorage / cookie)
  5. Client: Sends JWT in header: Authorization: Bearer <token>
  6. Server: JWT Filter extracts token → validates → sets SecurityContext
  7. Server: Request proceeds to controller if valid

9.4 ENTERPRISE JWT IMPLEMENTATION PATTERN
───────────────────────────────────────────
  Classes needed:
  - JwtService           → Generate/validate tokens
  - JwtAuthFilter        → OncePerRequestFilter → intercept every request
  - SecurityConfig       → SecurityFilterChain configuration
  - AuthController       → Login/register endpoints
  - UserDetailsService   → Load user from database

Interview Question: "How does JWT authentication work in Spring Boot?"
Answer: "Client sends credentials to login endpoint. Server validates and
 generates a JWT containing user details and expiration. Client sends this
 token in the Authorization header for subsequent requests. A custom
 OncePerRequestFilter extracts and validates the token on every request,
 sets the SecurityContext, and allows the request to proceed."


========================  PART 10: SPRING SECURITY (CONCEPTS)  ========================

10.1 ARCHITECTURE
──────────────────
  HTTP Request → DelegatingFilterProxy → FilterChainProxy → SecurityFilterChain
  
  SecurityFilterChain contains ordered filters:
  1. CorsFilter
  2. CsrfFilter
  3. UsernamePasswordAuthenticationFilter
  4. JwtAuthenticationFilter (custom)
  5. ExceptionTranslationFilter
  6. FilterSecurityInterceptor (authorization)

10.2 AUTHENTICATION vs AUTHORIZATION
──────────────────────────────────────
  Authentication: WHO are you?    → Verify identity (login)
  Authorization:  WHAT can you do? → Verify permissions (roles)

10.3 KEY COMPONENTS
────────────────────
  AuthenticationManager    → Coordinates authentication
  UserDetailsService       → Loads user from DB
  PasswordEncoder          → BCrypt hashing
  SecurityFilterChain      → Defines security rules
  SecurityContext          → Holds authenticated user info

10.4 ROLE-BASED AUTHORIZATION
──────────────────────────────
  @PreAuthorize("hasRole('ADMIN')")  → Method-level security
  @Secured("ROLE_USER")             → Simpler role check
  .requestMatchers("/admin/**").hasRole("ADMIN")  → URL-level security

Interview Question: "Explain Spring Security filter chain"
Answer: "Spring Security uses a chain of servlet filters. Each filter handles
 a specific security concern: CORS, CSRF, authentication, exception handling,
 and authorization. Custom filters like JwtAuthFilter are inserted into this
 chain to handle token-based authentication."

========================  PART 11: EXCEPTION HANDLING (YOUR PROJECT)  ========================

11.1 YOUR GlobalExceptionHandler.java
───────────────────────────────────────
  @ControllerAdvice  ← Applies to ALL controllers globally
  public class GlobalExceptionHandler {

      @ExceptionHandler(MethodArgumentNotValidException.class)  ← Validation errors
      @ExceptionHandler(IllegalArgumentException.class)         ← Bad input
      @ExceptionHandler(IllegalStateException.class)            ← Config errors (AI)
      @ExceptionHandler(Exception.class)                        ← Catch-all fallback
  }

11.2 HOW @ControllerAdvice WORKS INTERNALLY
──────────────────────────────────────────────
  1. Spring scans and finds @ControllerAdvice class
  2. Registers it as an exception handler for all controllers
  3. When any controller throws an exception:
     a. DispatcherServlet catches it
     b. Looks for matching @ExceptionHandler method
     c. Most specific exception type wins
     d. Handler creates error response
     e. Returns ResponseEntity with error details

  Exception Resolution Order:
    MethodArgumentNotValidException → handleValidationExceptions()
    IllegalArgumentException        → handleIllegalArgumentException()
    IllegalStateException           → handleIllegalStateException()
    Any other Exception             → handleGlobalException() (fallback)

11.3 YOUR ERROR RESPONSE FORMAT
─────────────────────────────────
  {
    "timestamp": "2025-01-15T10:30:00",
    "status": 400,
    "error": "Validation Failed",
    "errors": {
      "customerName": "Customer name is required",
      "principalAmount": "Principal amount must be positive"
    },
    "path": "/Spr/customers/insertCustomer"
  }

11.4 VALIDATION ERROR HANDLING FLOW
──────────────────────────────────────
  Client sends: POST /Spr/customers/insertCustomer
  Body: {"customerName": "", "principalAmount": -100}

  1. @Valid on controller method triggers Hibernate Validator
  2. @NotBlank fails on customerName → FieldError created
  3. @Positive fails on principalAmount → FieldError created
  4. MethodArgumentNotValidException thrown (contains all errors)
  5. GlobalExceptionHandler catches it
  6. Extracts all FieldErrors into a Map
  7. Returns 400 BAD_REQUEST with structured error response

11.5 ENTERPRISE EXCEPTION HANDLING BEST PRACTICES
───────────────────────────────────────────────────
  ✅ Use @ControllerAdvice for centralized handling
  ✅ Create custom exceptions (CustomerNotFoundException)
  ✅ Return consistent error response structure
  ✅ Don't expose internal stack traces to client
  ✅ Log exceptions server-side
  ✅ Use appropriate HTTP status codes

Interview Question: "How do you handle exceptions globally in Spring Boot?"
Answer: "I use @ControllerAdvice with @ExceptionHandler methods. This
 centralizes exception handling across all controllers. Each handler
 targets specific exception types and returns a structured error
 response with timestamp, status, message, and path. Validation errors
 from @Valid are caught via MethodArgumentNotValidException."


========================  PART 12: CONFIGURATION LAYER (YOUR PROJECT)  ========================

12.1 @Configuration CLASSES IN YOUR PROJECT
─────────────────────────────────────────────
  1. CorsConfig — Cross-Origin Resource Sharing
  2. ModelMapperExp — Object mapping bean

12.2 CorsConfig EXPLAINED
───────────────────────────
  @Configuration
  public class CorsConfig implements WebMvcConfigurer {
      @Override
      public void addCorsMappings(CorsRegistry registry) {
          registry.addMapping("/**")                    ← All endpoints
              .allowedOrigins("http://localhost:4200",   ← Angular app
                              "http://localhost:3000")   ← React app
              .allowedMethods("GET","POST","PUT","DELETE","OPTIONS")
              .allowedHeaders("*")
              .allowCredentials(true)
              .maxAge(3600);                             ← Cache preflight 1 hour
      }
  }

  WHY CORS?
    Browser enforces Same-Origin Policy
    Your Angular app (port 4200) calls Backend (port 8080)
    Different ports = different origin = blocked by browser
    CORS config tells browser: "Allow requests from these origins"

12.3 ModelMapperExp — Bean Configuration
──────────────────────────────────────────
  @Configuration
  public class ModelMapperExp {
      @Bean
      ModelMapper modelMapper() {
          return new ModelMapper();
      }
  }

  HOW @Bean WORKS INTERNALLY:
    1. Spring finds @Configuration class during component scan
    2. Creates a CGLIB proxy of the class
    3. Calls @Bean methods ONCE to create bean instances
    4. Stores beans in ApplicationContext (singleton by default)
    5. Any class that needs ModelMapper gets the SAME instance injected

12.4 application.yml EXPLAINED
────────────────────────────────
  spring:
    datasource:
      url: jdbc:mysql://localhost:3306/testschema   ← Database connection URL
      username: root                                 ← DB credentials
      password: 2580
      driver-class-name: com.mysql.cj.jdbc.Driver   ← MySQL JDBC driver

    jpa:
      hibernate:
        ddl-auto: update    ← Auto-create/update tables from entities
      show-sql: true        ← Print SQL queries in console
      properties:
        hibernate:
          format_sql: true  ← Pretty-print SQL
          dialect: org.hibernate.dialect.MySQL8Dialect ← MySQL-specific SQL

  server:
    port: 8080              ← Tomcat listens on this port

  logging:
    level:
      com.SprCustomers: DEBUG             ← Your package logs at DEBUG
      org.hibernate.SQL: DEBUG            ← See Hibernate SQL
      org.hibernate.type...BasicBinder: TRACE ← See SQL parameter values

  DDL-AUTO OPTIONS:
    none     → No schema changes (production)
    validate → Validates schema matches entities (production)
    update   → Updates schema without data loss (development) ← YOUR PROJECT
    create   → Drops and recreates tables (testing)
    create-drop → create + drop on shutdown (testing)

Interview Question: "What is ddl-auto and which value do you use in production?"
Answer: "ddl-auto controls how Hibernate manages the database schema.
 In development I use 'update' which adds new columns/tables without data loss.
 In production I use 'validate' or 'none' and manage schema changes through
 Flyway or Liquibase migration scripts for safety and auditability."


========================  PART 13: DEPENDENCY INJECTION INTERNAL WORKING  ========================

13.1 WHAT IS DEPENDENCY INJECTION
───────────────────────────────────
  Instead of:
    CustomerController controller = new CustomerController(
        new customerServiceImpl(new CustomerRepository(), new ModelMapper())
    );

  Spring does:
    @RestController
    public class CustomerController {
        private final CustomerService service;  ← Spring injects this
    }

13.2 THREE TYPES OF DI
───────────────────────
  CONSTRUCTOR INJECTION (✅ Best Practice — YOUR PROJECT uses this):
    public CustomerController(CustomerService service) {
        this.service = service;
    }
    → Immutable (final fields)
    → All dependencies required at construction
    → Easy to test

  FIELD INJECTION (❌ Avoid):
    @Autowired
    private CustomerService service;
    → Cannot use final
    → Hard to test
    → Hides dependencies

  SETTER INJECTION (⚠️ Optional dependencies):
    @Autowired
    public void setService(CustomerService service) {
        this.service = service;
    }
    → For optional dependencies

13.3 IoC CONTAINER INTERNAL WORKING
─────────────────────────────────────
  BeanFactory (basic) → ApplicationContext (full-featured)

  ApplicationContext provides:
    - Bean lifecycle management
    - Dependency injection
    - Event publishing
    - Resource loading
    - AOP support

13.4 BEAN SCOPES
─────────────────
  singleton   → ONE instance per ApplicationContext (DEFAULT) ← Your beans
  prototype   → NEW instance every time requested
  request     → ONE instance per HTTP request (web only)
  session     → ONE instance per HTTP session (web only)
  application → ONE instance per ServletContext

Interview Question: "Explain Constructor vs Field Injection"
Answer: "Constructor injection is the recommended approach because it makes
 dependencies explicit, enables immutable (final) fields, ensures all
 required dependencies are injected at creation, and makes testing easier.
 Field injection hides dependencies and prevents using final fields."


========================  PART 14: SPRING BOOT INTERNAL WORKING  ========================

14.1 AUTO-CONFIGURATION DEEP DIVE
───────────────────────────────────
  Spring Boot reads: META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

  For YOUR project, key auto-configurations:
    DataSourceAutoConfiguration      → Creates MySQL DataSource bean
    HibernateJpaAutoConfiguration    → Creates EntityManagerFactory
    TransactionAutoConfiguration     → Creates PlatformTransactionManager
    WebMvcAutoConfiguration          → Configures DispatcherServlet
    JacksonAutoConfiguration         → Configures JSON serializer
    ValidationAutoConfiguration      → Sets up Hibernate Validator

  @Conditional Annotations:
    @ConditionalOnClass       → Only if class is on classpath
    @ConditionalOnProperty    → Only if property is set
    @ConditionalOnMissingBean → Only if no custom bean defined

14.2 DispatcherServlet INTERNAL WORKING
─────────────────────────────────────────
  DispatcherServlet = Front Controller pattern

  Request Processing Pipeline:
  ┌─────────────┐
  │ HTTP Request │
  └──────┬──────┘
         ▼
  ┌──────────────────────┐
  │ DispatcherServlet    │ ← doDispatch() called
  │ getHandler()         │ → Finds matching controller method
  │ getHandlerAdapter()  │ → Gets adapter to invoke method
  │ handle()             │ → Invokes controller method
  │ processResult()      │ → Converts return to HTTP response
  └──────────────────────┘

  HandlerMapping Resolution:
    RequestMappingHandlerMapping scans all @RequestMapping annotations
    Creates a map: URL pattern → Controller method
    GET /Spr/customers/getAllCustomers → CustomerController.getAllCustomerDetails()

14.3 REQUEST PROCESSING DETAILED FLOW
───────────────────────────────────────
  1. Tomcat accepts connection → creates Request/Response objects
  2. Filter chain executes (CORS filter, etc.)
  3. DispatcherServlet.doDispatch() invoked
  4. HandlerMapping matches URL to controller method
  5. HandlerAdapter prepares method invocation
  6. Argument resolvers process parameters:
     - RequestParamMethodArgumentResolver → @RequestParam
     - RequestResponseBodyMethodProcessor → @RequestBody (Jackson)
     - PathVariableMethodArgumentResolver → @PathVariable
  7. Validation runs if @Valid present
  8. Controller method executes
  9. Return value handler processes response:
     - ResponseEntity → extracts status + headers + body
     - Jackson serializes body to JSON
  10. Response sent to client


========================  PART 15: DATABASE INTEGRATION  ========================

15.1 CONNECTION FLOW
─────────────────────
  application.yml → DataSource → ConnectionPool (HikariCP) → MySQL

  HikariCP (default connection pool):
    - Maintains pool of database connections
    - Default: 10 connections
    - Reuses connections instead of creating new ones
    - Dramatically improves performance

15.2 JPA ENTITY LIFECYCLE
───────────────────────────
  new CustomerBo()
    → TRANSIENT (not managed, not in DB)
  repository.save(bo)
    → MANAGED/PERSISTENT (in persistence context + DB)
  Transaction ends
    → DETACHED (no longer tracked)
  repository.delete(bo)
    → REMOVED (scheduled for deletion)

15.3 TRANSACTION LIFECYCLE (YOUR PROJECT)
──────────────────────────────────────────
  @Transactional on service method:

  BEGIN TRANSACTION
    → EntityManager opens Session
    → Persistence Context created (L1 Cache)
    → Operations execute (find, save, delete)
    → Dirty checking: Hibernate detects changes
    → Flush: SQL generated and sent to DB
  COMMIT TRANSACTION
    → Changes permanently saved
    → Persistence Context cleared

  On RuntimeException:
  ROLLBACK TRANSACTION
    → All changes reverted
    → Database unchanged


========================  PART 16: COMPLETE END-TO-END REQUEST FLOW  ========================

SCENARIO: Insert a new customer

  Client: POST http://localhost:8080/Spr/customers/insertCustomer
  Body: {"customerName":"Ravi","customerAddress":"Hyderabad",
         "principalAmount":50000,"rate":12,"time":2}

  STEP 1 — NETWORK LAYER
    Tomcat receives TCP connection on port 8080
    HTTP request parsed → HttpServletRequest created

  STEP 2 — FILTER CHAIN
    CorsFilter processes → allows request from configured origins
    (No Security Filter in your project currently)

  STEP 3 — DISPATCHER SERVLET
    DispatcherServlet.doDispatch()
    HandlerMapping: POST /Spr/customers/insertCustomer
      → CustomerController.insertCustomer()

  STEP 4 — ARGUMENT RESOLUTION
    @RequestBody → Jackson ObjectMapper reads JSON body
    → Deserializes to CustomerDto object
    @Valid → Hibernate Validator validates:
      customerName: "Ravi" → @NotBlank ✅
      principalAmount: 50000 → @NotNull @Positive ✅

  STEP 5 — CONTROLLER
    CustomerController.insertCustomer(customerDto)
    → Calls service.insertCustomer(customerDto)

  STEP 6 — SERVICE LAYER
    customerServiceImpl.insertCustomer(customerDto)
    → Null check on input
    → Creates new CustomerBo (entity)
    → Maps DTO fields to BO fields
    → Calls customerRepository.save(bo)

  STEP 7 — REPOSITORY → HIBERNATE → DATABASE
    JpaRepository.save(bo) → SimpleJpaRepository.save()
    → EntityManager.persist(bo) (new entity, no ID)
    → Hibernate generates: INSERT INTO Spring_Customers 
        (Customer_Name, Customer_Address, Principle_Amount, Interest_Rate, Time)
        VALUES ('Ravi', 'Hyderabad', 50000, 12, 2)
    → MySQL executes INSERT → returns auto-generated CID

  STEP 8 — RESPONSE FLOW BACK
    Database → BO (with generated ID) → toDto(bo)
    → Interest = (50000 × 12 × 2) / 100 = 12000
    → Total = 50000 + 12000 = 62000
    → DTO returned to controller

  STEP 9 — CONTROLLER RESPONSE
    Controller formats response string
    Returns ResponseEntity.status(201).body(responseString)

  STEP 10 — HTTP RESPONSE
    Jackson serializes → JSON response
    HTTP Status: 201 CREATED
    Response sent to client


========================  PART 17: PERFORMANCE OPTIMIZATION  ========================

17.1 TECHNIQUES FOR YOUR PROJECT
──────────────────────────────────
  Connection Pooling (HikariCP):
    Already enabled by default in Spring Boot
    Tuning: spring.datasource.hikari.maximum-pool-size=20

  @Transactional(readOnly = true):
    YOUR PROJECT uses this for read operations ✅
    Hibernate skips dirty checking → better performance

  Lazy vs Eager Loading:
    @ManyToOne(fetch = FetchType.LAZY)  → Load on access (preferred)
    @ManyToOne(fetch = FetchType.EAGER) → Load immediately (N+1 risk)

  Caching:
    @Cacheable("customers") → Cache method results
    @CacheEvict → Invalidate cache on updates
    Requires: spring-boot-starter-cache dependency

  Pagination:
    Use: Page<CustomerBo> findAll(Pageable pageable)
    Instead of: List<CustomerBo> findAll() ← loading entire table

  Query Optimization:
    Use @Query with JPQL for complex queries
    Use projections (interfaces) for partial data loading


========================  PART 18: ENTERPRISE BEST PRACTICES  ========================

  ✅ Layered Architecture      → Controller/Service/Repository separation
  ✅ Interface-based Services   → Loose coupling, testability
  ✅ Constructor Injection      → Immutable, testable dependencies
  ✅ DTO Pattern                → Decouple API from database
  ✅ Global Exception Handling  → Consistent error responses
  ✅ Bean Validation            → @Valid with constraint annotations
  ✅ Transaction Management     → @Transactional on service methods
  ✅ API Documentation          → Swagger/OpenAPI with annotations
  ✅ CORS Configuration         → Secure cross-origin access

  ⚠️ IMPROVEMENTS FOR YOUR PROJECT:
  • Add Spring Security + JWT Authentication
  • Add custom exception classes (CustomerNotFoundException)
  • Replace System.out.println with SLF4J logging
  • Add pagination for getAllCustomers
  • Add unit tests and integration tests
  • Use environment variables for database credentials
  • Add rate limiting for AI endpoint
  • Profile-based config (application-dev.yml, application-prod.yml)


========================  PART 19: INTERVIEW QUESTIONS & ANSWERS  ========================

── BEGINNER LEVEL ──

Q1: What is Spring Boot?
A: Spring Boot is an opinionated framework built on Spring that simplifies
   configuration through auto-configuration, provides embedded servers, and
   enables rapid development with production-ready features.

Q2: What is the difference between @Component, @Service, @Repository, @Controller?
A: All are stereotypes of @Component (auto-detected by component scan).
   @Service → Business logic layer
   @Repository → Data access layer (translates persistence exceptions)
   @Controller → Web layer (MVC)
   Each adds semantic clarity about the bean's role.

Q3: What is application.yml?
A: Externalized configuration file for Spring Boot. It uses YAML format to
   configure datasource, server port, JPA settings, logging levels, etc.
   Spring Boot reads it at startup to configure auto-configured beans.

Q4: What is @Autowired?
A: It instructs Spring to automatically inject a dependency. With constructor
   injection (one constructor), @Autowired is optional since Spring Boot 4.3+.

Q5: What is ResponseEntity?
A: A class that represents the complete HTTP response — status code, headers,
   and body. Example: ResponseEntity.status(HttpStatus.OK).body(data)

── INTERMEDIATE LEVEL ──

Q6: What is @Transactional and how does it work internally?
A: @Transactional creates a proxy around the bean. Before the method, it
   begins a transaction. If the method completes normally, it commits. If a
   RuntimeException occurs, it rolls back. readOnly=true optimizes read
   operations by skipping dirty checking.

Q7: Explain Spring Data JPA query derivation.
A: Spring Data parses method names to generate JPQL. "findByCustomerName"
   becomes "SELECT c FROM CustomerBo c WHERE c.customerName = ?1".
   Keywords: findBy, deleteBy, countBy, existsBy with And/Or/OrderBy.

Q8: What is the N+1 problem?
A: When loading a parent entity with a collection, Hibernate executes 1 query
   for parents and N queries for each parent's children. Fix with JOIN FETCH,
   @EntityGraph, or @BatchSize.

Q9: Explain the difference between JPA and Hibernate.
A: JPA is a specification (interfaces), Hibernate is an implementation.
   JPA defines: EntityManager, @Entity, JPQL.
   Hibernate provides: Session, caching, dirty checking, query generation.

Q10: What is ModelMapper and why use it?
A: ModelMapper automatically maps properties between objects (BO ↔ DTO).
    It uses convention-based mapping: same-named properties are mapped
    automatically. Reduces boilerplate mapping code.

── ADVANCED LEVEL ──

Q11: How does Spring Boot auto-configuration work internally?
A: Spring Boot reads AutoConfiguration.imports file, loads configuration
    classes with @Conditional annotations that check classpath, properties,
    and existing beans. Only matching configurations are applied.

Q12: Explain Spring Bean lifecycle in detail.
A: Instantiation → Populate Properties → BeanNameAware → ApplicationContextAware
    → @PostConstruct → InitializingBean.afterPropertiesSet() → Custom init
    → Bean Ready → @PreDestroy → DisposableBean.destroy() → Custom destroy

Q13: What is Spring AOP and how is @Transactional implemented?
A: Spring AOP uses proxies (JDK dynamic or CGLIB) to intercept method calls.
    @Transactional creates a proxy that wraps the method with transaction
    management. The proxy calls TransactionInterceptor which manages
    begin/commit/rollback around the actual method invocation.

Q14: Explain Hibernate's persistence context and first-level cache.
A: The persistence context is a map of (EntityType, ID) → Entity instance.
    Within a transaction, findById(5) called twice returns the SAME object
    from the first-level cache. Dirty checking compares entity state at
    flush time to generate UPDATE SQL only for changed fields.

Q15: How does Spring resolve circular dependencies?
A: For singleton beans with setters, Spring creates "early references" stored
    in singletonFactories. Constructor-based circular dependencies cause
    BeanCurrentlyInCreationException. Solution: redesign, use @Lazy, or
    refactor to eliminate the cycle.

── SENIOR ARCHITECT LEVEL ──

Q16: How would you scale this monolithic application to microservices?
A: 1. Identify bounded contexts (Customer, Loan, AI)
   2. Extract each into independent Spring Boot services
   3. Add API Gateway (Spring Cloud Gateway)
   4. Service discovery (Eureka/Consul)
   5. Inter-service communication (REST/gRPC/Kafka)
   6. Distributed tracing (Zipkin/Jaeger)
   7. Centralized config (Spring Cloud Config)
   8. Circuit breaker (Resilience4J)

Q17: How would you implement caching strategy for this project?
A: L1: Hibernate first-level cache (per transaction, already exists)
   L2: Hibernate second-level cache (EhCache/Redis)
   L3: Spring Cache (@Cacheable on getAllCustomers())
   L4: CDN for static content
   Eviction: @CacheEvict on insert/update/delete operations

Q18: How would you secure this application end-to-end?
A: 1. Spring Security + JWT authentication
   2. HTTPS/TLS encryption
   3. Input validation (done with @Valid)
   4. SQL injection protection (JPA parameterized queries)
   5. CORS properly configured (done)
   6. Rate limiting (bucket4j)
   7. Secrets management (Vault/env vars for DB creds)
   8. OWASP dependency check

── SCENARIO-BASED QUESTIONS ──

Q19: "Your getAllCustomers endpoint is slow with 1M records. How do you fix it?"
A: 1. Add pagination: Pageable + Page<CustomerBo>
   2. Add database indexes on frequently queried columns
   3. Cache results with @Cacheable + TTL
   4. Use JPQL projections for partial column loading
   5. Consider database read replicas for read-heavy workload

Q20: "Two users update the same customer simultaneously. What happens?"
A: Without optimistic locking, last write wins (data loss risk).
   Solution: Add @Version field to entity. Hibernate checks version on update.
   If version mismatch, throws OptimisticLockException → return 409 CONFLICT.

Q21: "Your Gemini AI endpoint takes 30 seconds. The thread pool is exhausted."
A: 1. Make AI calls async: @Async + CompletableFuture
   2. Increase Tomcat thread pool for long-running requests
   3. Implement WebFlux for reactive/non-blocking calls
   4. Add circuit breaker with fallback response
   5. Cache frequent AI queries
   6. Return 202 Accepted → poll for result (async pattern)


========================  PART 20: YOUR PROJECT'S DEPENDENCY TREE  ========================

  pom.xml Dependencies:
  ┌─────────────────────────────────────────────────────────┐
  │ spring-boot-starter-web        → Tomcat + Spring MVC   │
  │ spring-boot-starter-data-jpa   → Hibernate + JPA       │
  │ spring-boot-starter-data-jdbc  → Spring JDBC           │
  │ spring-boot-starter-validation → Bean Validation       │
  │ spring-boot-starter-test       → JUnit + Mockito       │
  │ mysql-connector-j              → MySQL JDBC driver      │
  │ mssql-jdbc                     → SQL Server driver      │
  │ lombok 1.18.36                 → Code generation        │
  │ modelmapper 3.2.5              → Object mapping         │
  │ org.json 20231013              → JSON parsing (AI)      │
  │ springdoc-openapi 2.2.0        → Swagger UI + OpenAPI  │
  └─────────────────────────────────────────────────────────┘


================================================================================
                         END OF ANALYSIS NOTES
================================================================================

  Generated: 2026-02-24
  Project: Customer_Management_Services
  Author: Enterprise Spring Boot Backend Analysis
  Purpose: Interview Preparation + Architecture Understanding
